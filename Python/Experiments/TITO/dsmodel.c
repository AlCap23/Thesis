/* DSblock model generated by Dymola from Modelica model MIMO_Study.TITO_FOTD_CLOSED
 Dymola Version 2017 FD01 (64-bit), 2016-10-11 translated this at Wed Aug 30 17:37:39 2017

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    7
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    72
#define NP_    51
#define NPS_   0
#define MAXAuxStr_   9
#define MAXAuxStrLen_   500
#define NHash1_ -390095730
#define NHash2_ 301563410
#define NHash3_ 0
#define NI_    0
#define NRelF_ 6
#define NRel_  6
#define NTim_  4
#define NSamp_ 0
#define NCons_ 0
#define NA_    58
#define SizePre_ 3
#define SizeEq_ 0
#define SizeDelay_ 8
#define QNLmax_ 0
#define MAXAux 6
#define NrDymolaTimers_ 0
#define NWhen_ 6
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="MIMO_Study.TITO_FOTD_CLOSED";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/juliu/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[14]={6 , 2 , 1 , 6 , 1 , 2 , 1 , 3 , 1 , 4 , 1 , 5
   , 1 , 7};
DYMOLA_STATIC int QJacobianGC_[43]={
1 , 1 , 6 , 6 , 1 , 6 , 0 , 2 , 2 , 2 , 2 , 0 , 2 , 2 , 3 , 3 , 3 , 0 , 3 , 0 , 0
   , 4 , 4 , 4 , 4 , 0 , 4 , 4 , 5 , 5 , 0 , 0 , 5 , 0 , 0 , 7 , 7 , 0 , 0 , 0
   , 0 , 7 , 0};
DYMOLA_STATIC double QJacobianCD_[8]={0  , 44 , 50 , 54 , 56 , 56 , 99 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,27) = false;
DYNX(W_,28) = false;
DYNX(W_,29) = false;
DYNX(W_,31) = false;
DYNX(W_,32) = false;
DYNX(W_,43) = false;
DYNX(W_,44) = false;
DYNX(W_,45) = false;
DYNX(W_,47) = false;
DYNX(W_,48) = false;
DYNX(W_,59) = false;
DYNX(W_,60) = false;
DYNX(W_,61) = false;
DYNX(W_,63) = false;
DYNX(W_,64) = false;
DYNX(W_,2) = 3;
DYNX(W_,13) = 3;
DYNX(W_,17) = 3;
DYNX(W_,21) = 3;
#endif
DYNSetAuxString(did_, "PI", 0);
DYNSetAuxString(did_, "ki", 1);
DYNSetAuxString(did_, "initialOutput", 2);
DYNSetAuxString(did_, "PI", 3);
DYNSetAuxString(did_, "ki", 4);
DYNSetAuxString(did_, "initialOutput", 5);
DYNSetAuxString(did_, "PI", 6);
DYNSetAuxString(did_, "ki", 7);
DYNSetAuxString(did_, "initialOutput", 8);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,26) = false;
DYNX(W_,42) = false;
DYNX(W_,58) = false;
#endif
BoundParameterSection
DYNX(W_,0) = DYNX(DP_,4);
DYNX(W_,1) = DYNX(DP_,8);
DYNX(W_,4) = DYNX(DP_,12);
DYNX(W_,11) = DYNX(DP_,5);
DYNX(W_,12) = DYNX(DP_,9);
DYNX(W_,14) = DYNX(DP_,13);
DYNX(W_,15) = DYNX(DP_,6);
DYNX(W_,16) = DYNX(DP_,10);
DYNX(W_,18) = DYNX(DP_,14);
DYNX(W_,19) = DYNX(DP_,7);
DYNX(W_,20) = DYNX(DP_,11);
DYNX(W_,22) = DYNX(DP_,15);
DYNX(W_,30) =  -DYNX(DP_,32);
AssertModelica(DYNX(DP_,32) >= DYNX(W_,30),"pIController.yMax >= pIController.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("PI controller output limits are not consistent: yMax (=",
  Real2String2(DYNX(DP_,32), true, 0)),") < yMin (="),Real2String2(DYNX(W_,30), 
  true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,33) >= DYNX(W_,30) AND DYNX(DP_,33) <= DYNX(DP_,32),
  "pIController.yInitial >= pIController.yMin and pIController.yInitial <= pIController.yMax",
   "Output of PI controller yInitial must be between limits.");
DYNX(W_,37) = DYNX(DP_,29);
DYNX(W_,38) = DYNX(DP_,31);
DYNX(W_,39) = DYNX(DP_,30);
DYNX(W_,46) =  -DYNX(DP_,39);
AssertModelica(DYNX(DP_,39) >= DYNX(W_,46),"pIController1.yMax >= pIController1.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("PI controller output limits are not consistent: yMax (=",
  Real2String2(DYNX(DP_,39), true, 0)),") < yMin (="),Real2String2(DYNX(W_,46), 
  true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,40) >= DYNX(W_,46) AND DYNX(DP_,40) <= DYNX(DP_,39),
  "pIController1.yInitial >= pIController1.yMin and pIController1.yInitial <= pIController1.yMax",
   "Output of PI controller yInitial must be between limits.");
DYNX(W_,53) = DYNX(DP_,36);
DYNX(W_,54) = DYNX(DP_,38);
DYNX(W_,55) = DYNX(DP_,37);
DYNX(W_,62) =  -DYNX(DP_,46);
AssertModelica(DYNX(DP_,46) >= DYNX(W_,62),"pIController2.yMax >= pIController2.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("PI controller output limits are not consistent: yMax (=",
  Real2String2(DYNX(DP_,46), true, 0)),") < yMin (="),Real2String2(DYNX(W_,62), 
  true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,47) >= DYNX(W_,62) AND DYNX(DP_,47) <= DYNX(DP_,46),
  "pIController2.yInitial >= pIController2.yMin and pIController2.yInitial <= pIController2.yMax",
   "Output of PI controller yInitial must be between limits.");
DYNX(W_,69) = DYNX(DP_,43);
DYNX(W_,70) = DYNX(DP_,45);
DYNX(W_,71) = DYNX(DP_,44);
InitialSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,24) = DYNX(DP_,33);
DYNX(W_,40) = DYNX(DP_,40);
DYNX(W_,56) = DYNX(DP_,47);
DYNX(X_,0) = DYNX(DP_,16);
DYNX(X_,1) = DYNX(DP_,21);
DYNX(X_,2) = DYNX(DP_,22);
DYNX(X_,3) = DYNX(DP_,23);
InitialSection
DefaultSection
InitializeData(0)
InitialSection
DYNX(Aux_,0) = DYNX(W_,24);
DYNX(Aux_,1) = DYNX(W_,35);
DYNX(Aux_,2) = DYNX(W_,40);
DYNX(Aux_,3) = DYNX(W_,51);
DYNX(Aux_,4) = DYNX(W_,56);
DYNX(Aux_,5) = DYNX(W_,67);
InitialSection
InitialSection2
DYNX(W_,51) = DYNX(DP_,40);
DYNX(W_,35) = DYNX(DP_,33);
DYNX(W_,67) = DYNX(DP_,47);
DYNX(X_,0) = DYNX(DP_,16);
DYNX(X_,2) = DYNX(DP_,22);
DYNX(W_,23) = DYNX(DP_,25)+(IF LessTime(DYNX(DP_,26), 0) THEN 0 ELSE 
  DYNX(DP_,24));
DYNX(W_,3) = delay(DYNX(X_,0), DYNX(W_,4), DYNX(W_,4), 0, "delay(tITO_FOTD.firstOrder.y, tITO_FOTD.fixedDelay.delayTime)");
DYNX(W_,8) = delay(DYNX(X_,2), DYNX(W_,18), DYNX(W_,18), 1, "delay(tITO_FOTD.firstOrder2.y, tITO_FOTD.fixedDelay2.delayTime)");
DYNX(W_,6) = DYNX(DP_,17)*DYNX(W_,3)+DYNX(DP_,18)*DYNX(W_,8);
DYNX(W_,25) = DYNX(W_,23)-DYNX(W_,6);
DYNX(X_,4) = DYNX(DP_,33)-DYNX(W_,37)*DYNX(W_,25);
DYNX(W_,33) = GreaterEqualTime(DYNX(DP_,34), 1);
DYNX(W_,34) = DYNX(W_,37)*DYNX(W_,25)+DYNX(X_,4);
DYNX(W_,24) = IF DYNX(W_,33) THEN (IF GreaterS(DYNX(W_,34),"pIController.y_unlim",
   DYNX(DP_,32),"pIController.yMax", 0) THEN DYNX(DP_,32) ELSE IF LessS(
  DYNX(W_,34),"pIController.y_unlim", DYNX(W_,30),"pIController.yMin", 1) THEN 
  DYNX(W_,30) ELSE DYNX(W_,34)) ELSE DYNX(W_,35);
InitialSection
DYNX(Aux_,0) = DYNX(W_,24);
DYNX(Aux_,1) = DYNX(W_,35);
InitialSection2
DYNX(X_,1) = DYNX(DP_,21);
DYNX(X_,3) = DYNX(DP_,23);
DYNX(W_,9) = delay(DYNX(X_,1), DYNX(W_,14), DYNX(W_,14), 2, "delay(tITO_FOTD.firstOrder1.y, tITO_FOTD.fixedDelay1.delayTime)");
DYNX(W_,10) = delay(DYNX(X_,3), DYNX(W_,22), DYNX(W_,22), 3, "delay(tITO_FOTD.firstOrder3.y, tITO_FOTD.fixedDelay3.delayTime)");
DYNX(W_,7) = DYNX(DP_,19)*DYNX(W_,9)+DYNX(DP_,20)*DYNX(W_,10);
DYNX(W_,41) = DYNX(DP_,27)-DYNX(W_,7);
DYNX(X_,5) = DYNX(DP_,40)-DYNX(W_,53)*DYNX(W_,41);
DYNX(W_,49) = GreaterEqualTime(DYNX(DP_,41), 2);
DYNX(W_,50) = DYNX(W_,53)*DYNX(W_,41)+DYNX(X_,5);
DYNX(W_,40) = IF DYNX(W_,49) THEN (IF GreaterS(DYNX(W_,50),"pIController1.y_unlim",
   DYNX(DP_,39),"pIController1.yMax", 2) THEN DYNX(DP_,39) ELSE IF LessS(
  DYNX(W_,50),"pIController1.y_unlim", DYNX(W_,46),"pIController1.yMin", 3)
   THEN DYNX(W_,46) ELSE DYNX(W_,50)) ELSE DYNX(W_,51);
InitialSection
DYNX(Aux_,2) = DYNX(W_,40);
DYNX(Aux_,3) = DYNX(W_,51);
InitialSection2
DYNX(W_,57) = DYNX(DP_,27)-DYNX(W_,7);
DYNX(X_,6) = DYNX(DP_,47)-DYNX(W_,69)*DYNX(W_,57);
DYNX(W_,65) = GreaterEqualTime(DYNX(DP_,48), 3);
DYNX(W_,66) = DYNX(W_,69)*DYNX(W_,57)+DYNX(X_,6);
DYNX(W_,56) = IF DYNX(W_,65) THEN (IF GreaterS(DYNX(W_,66),"pIController2.y_unlim",
   DYNX(DP_,46),"pIController2.yMax", 4) THEN DYNX(DP_,46) ELSE IF LessS(
  DYNX(W_,66),"pIController2.y_unlim", DYNX(W_,62),"pIController2.yMin", 5)
   THEN DYNX(W_,62) ELSE DYNX(W_,66)) ELSE DYNX(W_,67);
InitialSection
DYNX(Aux_,4) = DYNX(W_,56);
DYNX(Aux_,5) = DYNX(W_,67);
InitialSection
InitialSection2
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,49) = GreaterEqualTime(DYNX(DP_,41), 2);
DYNX(W_,9) = delay(DYNX(X_,1), DYNX(W_,14), DYNX(W_,14), 4, "delay(tITO_FOTD.firstOrder1.y, tITO_FOTD.fixedDelay1.delayTime)");
DYNX(W_,10) = delay(DYNX(X_,3), DYNX(W_,22), DYNX(W_,22), 5, "delay(tITO_FOTD.firstOrder3.y, tITO_FOTD.fixedDelay3.delayTime)");
DYNX(W_,7) = DYNX(DP_,19)*DYNX(W_,9)+DYNX(DP_,20)*DYNX(W_,10);
DYNX(W_,41) = DYNX(DP_,27)-DYNX(W_,7);
DYNX(W_,50) = DYNX(W_,53)*DYNX(W_,41)+DYNX(X_,5);
beginwhenBlock
whenModelica( NOT DYNX(W_,49) AND  NOT initial(), 0) 
  DYNX(W_,51) = PRE(DYNX(W_,40), 0);
endwhenModelica()
endwhenBlock

DYNX(W_,40) = IF DYNX(W_,49) THEN (IF GreaterS(DYNX(W_,50),"pIController1.y_unlim",
   DYNX(DP_,39),"pIController1.yMax", 2) THEN DYNX(DP_,39) ELSE IF LessS(
  DYNX(W_,50),"pIController1.y_unlim", DYNX(W_,46),"pIController1.yMin", 3)
   THEN DYNX(W_,46) ELSE DYNX(W_,50)) ELSE DYNX(W_,51);
DYNX(F_,3) = divmacro(DYNX(W_,19)*DYNX(W_,40)-DYNX(X_,3),"tITO_FOTD.firstOrder3.k*pIController1.y-tITO_FOTD.firstOrder3.y",
  DYNX(W_,20),"tITO_FOTD.firstOrder3.T");
DYNX(W_,33) = GreaterEqualTime(DYNX(DP_,34), 1);
DYNX(W_,23) = DYNX(DP_,25)+(IF LessTime(DYNX(DP_,26), 0) THEN 0 ELSE 
  DYNX(DP_,24));
DYNX(W_,3) = delay(DYNX(X_,0), DYNX(W_,4), DYNX(W_,4), 6, "delay(tITO_FOTD.firstOrder.y, tITO_FOTD.fixedDelay.delayTime)");
DYNX(W_,8) = delay(DYNX(X_,2), DYNX(W_,18), DYNX(W_,18), 7, "delay(tITO_FOTD.firstOrder2.y, tITO_FOTD.fixedDelay2.delayTime)");
DYNX(W_,6) = DYNX(DP_,17)*DYNX(W_,3)+DYNX(DP_,18)*DYNX(W_,8);
DYNX(W_,25) = DYNX(W_,23)-DYNX(W_,6);
DYNX(W_,34) = DYNX(W_,37)*DYNX(W_,25)+DYNX(X_,4);
beginwhenBlock
whenModelica( NOT DYNX(W_,33) AND  NOT initial(), 1) 
  DYNX(W_,35) = PRE(DYNX(W_,24), 1);
endwhenModelica()
endwhenBlock

DYNX(W_,24) = IF DYNX(W_,33) THEN (IF GreaterS(DYNX(W_,34),"pIController.y_unlim",
   DYNX(DP_,32),"pIController.yMax", 0) THEN DYNX(DP_,32) ELSE IF LessS(
  DYNX(W_,34),"pIController.y_unlim", DYNX(W_,30),"pIController.yMin", 1) THEN 
  DYNX(W_,30) ELSE DYNX(W_,34)) ELSE DYNX(W_,35);
DYNX(W_,36) = divmacro(DYNX(W_,24)-DYNX(W_,34),"pIController.y-pIController.y_unlim",
  DYNX(W_,37),"pIController.k_in_.k");
DYNX(F_,4) = IF DYNX(W_,33) THEN DYNX(W_,38)*(DYNX(W_,25)+DYNX(W_,36)) ELSE 0.0;
DYNX(W_,52) = divmacro(DYNX(W_,40)-DYNX(W_,50),"pIController1.y-pIController1.y_unlim",
  DYNX(W_,53),"pIController1.k_in_.k");
DYNX(F_,5) = IF DYNX(W_,49) THEN DYNX(W_,54)*(DYNX(W_,41)+DYNX(W_,52)) ELSE 0.0;
DYNX(F_,2) = divmacro(DYNX(W_,15)*DYNX(W_,40)-DYNX(X_,2),"tITO_FOTD.firstOrder2.k*pIController1.y-tITO_FOTD.firstOrder2.y",
  DYNX(W_,16),"tITO_FOTD.firstOrder2.T");
DYNX(W_,65) = GreaterEqualTime(DYNX(DP_,48), 3);
DYNX(W_,57) = DYNX(DP_,27)-DYNX(W_,7);
DYNX(W_,66) = DYNX(W_,69)*DYNX(W_,57)+DYNX(X_,6);
beginwhenBlock
whenModelica( NOT DYNX(W_,65) AND  NOT initial(), 2) 
  DYNX(W_,67) = PRE(DYNX(W_,56), 2);
endwhenModelica()
endwhenBlock

DYNX(W_,56) = IF DYNX(W_,65) THEN (IF GreaterS(DYNX(W_,66),"pIController2.y_unlim",
   DYNX(DP_,46),"pIController2.yMax", 4) THEN DYNX(DP_,46) ELSE IF LessS(
  DYNX(W_,66),"pIController2.y_unlim", DYNX(W_,62),"pIController2.yMin", 5)
   THEN DYNX(W_,62) ELSE DYNX(W_,66)) ELSE DYNX(W_,67);
DYNX(W_,5) = DYNX(DP_,49)*DYNX(W_,24)+DYNX(DP_,50)*DYNX(W_,56);
DYNX(F_,0) = divmacro(DYNX(W_,0)*DYNX(W_,5)-DYNX(X_,0),"tITO_FOTD.firstOrder.k*tITO_FOTD.u_1-tITO_FOTD.firstOrder.y",
  DYNX(W_,1),"tITO_FOTD.firstOrder.T");
DYNX(F_,1) = divmacro(DYNX(W_,11)*DYNX(W_,5)-DYNX(X_,1),"tITO_FOTD.firstOrder1.k*tITO_FOTD.u_1-tITO_FOTD.firstOrder1.y",
  DYNX(W_,12),"tITO_FOTD.firstOrder1.T");
DYNX(W_,68) = divmacro(DYNX(W_,56)-DYNX(W_,66),"pIController2.y-pIController2.y_unlim",
  DYNX(W_,69),"pIController2.k_in_.k");
DYNX(F_,6) = IF DYNX(W_,65) THEN DYNX(W_,70)*(DYNX(W_,57)+DYNX(W_,68)) ELSE 0.0;

AcceptedSection1

AcceptedSection2

DefaultSection
CrossingSection
/* Start of reinit equations */
beginwhenBlock
whenModelica(DYNX(W_,65), 3) 
  reinit(DYNX(X_,6), PRE(DYNX(W_,56), 2)-DYNX(W_,69)*DYNX(W_,57));
endwhenModelica()
endwhenBlock

beginwhenBlock
whenModelica(DYNX(W_,49), 4) 
  reinit(DYNX(X_,5), PRE(DYNX(W_,40), 0)-DYNX(W_,53)*DYNX(W_,41));
endwhenModelica()
endwhenBlock

beginwhenBlock
whenModelica(DYNX(W_,33), 5) 
  reinit(DYNX(X_,4), PRE(DYNX(W_,24), 1)-DYNX(W_,37)*DYNX(W_,25));
endwhenModelica()
endwhenBlock

/* End of reinit equations */
DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("KPY[1, 1]", "", 0, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("KPY[1, 2]", "", 1, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("KPY[2, 1]", "", 2, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("KPY[2, 2]", "", 3, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.K[1, 1]", "", 4, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.K[1, 2]", "", 5, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.K[2, 1]", "", 6, 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.K[2, 2]", "", 7, 5.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.T[1, 1]", "", 8, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.T[1, 2]", "", 9, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.T[2, 1]", "", 10, 0.01, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.T[2, 2]", "", 11, 11.0, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.L[1, 1]", "", 12, 0.001, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.L[1, 2]", "", 13, 0.01, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.L[2, 1]", "", 14, 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.L[2, 2]", "", 15, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("tITO_FOTD.firstOrder.k", "Gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder.T", "Time Constant [s]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("tITO_FOTD.firstOrder.y_start", "Initial or guess value of output (= state)",\
 16, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("tITO_FOTD.firstOrder.u", "Connector of Real input signal", \
"tITO_FOTD.u_1", 1, 5, 5, 0)
DeclareState("tITO_FOTD.firstOrder.y", "Connector of Real output signal", 0, 0.0,\
 0.0,0.0,0.0,0,544)
DeclareDerivative("tITO_FOTD.firstOrder.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.fixedDelay.u", "Connector of Real input signal", \
"tITO_FOTD.firstOrder.y", 1, 1, 0, 0)
DeclareVariable("tITO_FOTD.fixedDelay.y", "Connector of Real output signal", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("tITO_FOTD.fixedDelay.delayTime", "Delay time of output with respect to input signal [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.u_1", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("tITO_FOTD.y_1", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.u_2", "", "pIController1.y", 1, 5, 40, 0)
DeclareVariable("tITO_FOTD.y_2", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.add.u1", "Connector of Real input signal 1", \
"tITO_FOTD.fixedDelay.y", 1, 5, 3, 0)
DeclareVariable("tITO_FOTD.add.u2", "Connector of Real input signal 2", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.add.y", "Connector of Real output signal", \
"tITO_FOTD.y_1", 1, 5, 6, 0)
DeclareParameter("tITO_FOTD.add.k1", "Gain of upper input", 17, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("tITO_FOTD.add.k2", "Gain of lower input", 18, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("tITO_FOTD.add1.u1", "Connector of Real input signal 1", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("tITO_FOTD.add1.u2", "Connector of Real input signal 2", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.add1.y", "Connector of Real output signal", \
"tITO_FOTD.y_2", 1, 5, 7, 0)
DeclareParameter("tITO_FOTD.add1.k1", "Gain of upper input", 19, 1, 0.0,0.0,0.0,\
0,560)
DeclareParameter("tITO_FOTD.add1.k2", "Gain of lower input", 20, 1, 0.0,0.0,0.0,\
0,560)
DeclareVariable("tITO_FOTD.firstOrder1.k", "Gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder1.T", "Time Constant [s]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder1.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("tITO_FOTD.firstOrder1.y_start", "Initial or guess value of output (= state)",\
 21, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("tITO_FOTD.firstOrder1.u", "Connector of Real input signal", \
"tITO_FOTD.u_1", 1, 5, 5, 0)
DeclareState("tITO_FOTD.firstOrder1.y", "Connector of Real output signal", 1, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("tITO_FOTD.firstOrder1.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.fixedDelay1.u", "Connector of Real input signal", \
"tITO_FOTD.firstOrder1.y", 1, 1, 1, 0)
DeclareAlias2("tITO_FOTD.fixedDelay1.y", "Connector of Real output signal", \
"tITO_FOTD.add1.u1", 1, 5, 9, 0)
DeclareVariable("tITO_FOTD.fixedDelay1.delayTime", "Delay time of output with respect to input signal [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder2.k", "Gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder2.T", "Time Constant [s]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder2.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("tITO_FOTD.firstOrder2.y_start", "Initial or guess value of output (= state)",\
 22, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("tITO_FOTD.firstOrder2.u", "Connector of Real input signal", \
"pIController1.y", 1, 5, 40, 0)
DeclareState("tITO_FOTD.firstOrder2.y", "Connector of Real output signal", 2, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("tITO_FOTD.firstOrder2.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.fixedDelay2.u", "Connector of Real input signal", \
"tITO_FOTD.firstOrder2.y", 1, 1, 2, 0)
DeclareAlias2("tITO_FOTD.fixedDelay2.y", "Connector of Real output signal", \
"tITO_FOTD.add.u2", 1, 5, 8, 0)
DeclareVariable("tITO_FOTD.fixedDelay2.delayTime", "Delay time of output with respect to input signal [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder3.k", "Gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder3.T", "Time Constant [s]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("tITO_FOTD.firstOrder3.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("tITO_FOTD.firstOrder3.y_start", "Initial or guess value of output (= state)",\
 23, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("tITO_FOTD.firstOrder3.u", "Connector of Real input signal", \
"pIController1.y", 1, 5, 40, 0)
DeclareState("tITO_FOTD.firstOrder3.y", "Connector of Real output signal", 3, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("tITO_FOTD.firstOrder3.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("tITO_FOTD.fixedDelay3.u", "Connector of Real input signal", \
"tITO_FOTD.firstOrder3.y", 1, 1, 3, 0)
DeclareAlias2("tITO_FOTD.fixedDelay3.y", "Connector of Real output signal", \
"tITO_FOTD.add1.u2", 1, 5, 10, 0)
DeclareVariable("tITO_FOTD.fixedDelay3.delayTime", "Delay time of output with respect to input signal [s]",\
 1, 0.0,0.0,0.0,0,513)
DeclareParameter("step.height", "Height of step", 24, 10, 0.0,0.0,0.0,0,560)
DeclareVariable("step.y", "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,640)
DeclareParameter("step.offset", "Offset of output signal y", 25, 0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 26, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("const.k", "Constant output value", 27, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("const.y", "Connector of Real output signal", "const.k", 1, 7, 27,\
 0)
DeclareAlias2("pIController.u_s", "Connector of setpoint input signal", "step.y", 1,\
 5, 23, 0)
DeclareAlias2("pIController.u_m", "Connector of measurement input signal", \
"tITO_FOTD.y_1", 1, 5, 6, 0)
DeclareVariable("pIController.y", "Connector of actuator output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pIController.u", "Differenz between setpoint and measurement aka control error",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pIController.invertFeedback", "true, if feedback signal is inverted [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController.offset", "Operating point, added to proportional output",\
 28, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pIController.k", "Proportional gain of controller", 29, 3.4, \
0.0,0.0,0.0,0,560)
DeclareParameter("pIController.Ti", "Time constant of Integrator block [s]", 30,\
 0.5, 1E-060,1E+100,0.0,0,560)
DeclareParameter("pIController.ki", "Integral gain [s-1]", 31, 2.8, 1E-060,\
1E+100,0.0,0,560)
DeclareVariable("pIController.use_kInput", "= true, if k defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController.use_TiInput", "= true, if Ti defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController.use_kiInput", "= true, if ki defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController.yMax", "Upper limit of output", 32, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("pIController.yMin", "Lower limit of output", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("pIController.yInitial", "Initial output of controller", 33, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pIController.use_activeInput", "= true, if controller is switched on/off externally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController.use_y_notActive", "= true, if output of not activated controller is defined externally. Otherwise output is hold at deactivation. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController.activationTime", "Time when controller is switched on [s]",\
 34, 0.0, 0.0,0.0,0.0,0,560)
DeclareVariable("pIController.getActive.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareAlias2("pIController.getActive.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pIController.getActive.u", 1, 5, 33, 1089)
DeclareAlias2("pIController.active_.y", "Value of Boolean output [:#(type=Boolean)]",\
 "pIController.getActive.u", 1, 5, 33, 1089)
DeclareVariable("pIController.y_unlim", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pIController.y_old", "", 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("pIController.u_antiWindUp", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("pIController.integral", "", 4, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pIController.der(integral)", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pIController.ki_internal", "", "pIController.ki_in_.k", 1, 5, 38,\
 1024)
DeclareAlias2("pIController.getInputs.ki_in", "[s-1]", "pIController.ki_in_.k", 1,\
 5, 38, 1024)
DeclareAlias2("pIController.getInputs.k_in", "", "pIController.k_in_.k", 1, 5, 37,\
 1024)
DeclareAlias2("pIController.getInputs.Ti_in", "[s]", "pIController.Ti_in_.k", 1,\
 5, 39, 1024)
DeclareAlias2("pIController.getInputs.y_notActive", "", "pIController.y_old", 1,\
 5, 35, 1088)
DeclareVariable("pIController.k_in_.k", "Constant output value", 1, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("pIController.k_in_.y", "Connector of Real output signal", \
"pIController.k_in_.k", 1, 5, 37, 1024)
DeclareVariable("pIController.ki_in_.k", "Constant output value [s-1]", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pIController.ki_in_.y", "Connector of Real output signal [s-1]", \
"pIController.ki_in_.k", 1, 5, 38, 1024)
DeclareVariable("pIController.Ti_in_.k", "Constant output value [s]", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pIController.Ti_in_.y", "Connector of Real output signal [s]", \
"pIController.Ti_in_.k", 1, 5, 39, 1024)
DeclareAlias2("pIController.y_notActive_.y", "Value of Real output", \
"pIController.y_old", 1, 5, 35, 1024)
DeclareAlias2("pIController1.u_s", "Connector of setpoint input signal", \
"const.k", 1, 7, 27, 0)
DeclareAlias2("pIController1.u_m", "Connector of measurement input signal", \
"tITO_FOTD.y_2", 1, 5, 7, 0)
DeclareVariable("pIController1.y", "Connector of actuator output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pIController1.u", "Differenz between setpoint and measurement aka control error",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pIController1.invertFeedback", "true, if feedback signal is inverted [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController1.offset", "Operating point, added to proportional output",\
 35, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pIController1.k", "Proportional gain of controller", 36, 8.2, \
0.0,0.0,0.0,0,560)
DeclareParameter("pIController1.Ti", "Time constant of Integrator block [s]", 37,\
 0.5, 1E-060,1E+100,0.0,0,560)
DeclareParameter("pIController1.ki", "Integral gain [s-1]", 38, 6.7, 1E-060,\
1E+100,0.0,0,560)
DeclareVariable("pIController1.use_kInput", "= true, if k defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController1.use_TiInput", "= true, if Ti defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController1.use_kiInput", "= true, if ki defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController1.yMax", "Upper limit of output", 39, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("pIController1.yMin", "Lower limit of output", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareParameter("pIController1.yInitial", "Initial output of controller", 40, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pIController1.use_activeInput", "= true, if controller is switched on/off externally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController1.use_y_notActive", "= true, if output of not activated controller is defined externally. Otherwise output is hold at deactivation. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController1.activationTime", "Time when controller is switched on [s]",\
 41, 0.0, 0.0,0.0,0.0,0,560)
DeclareVariable("pIController1.getActive.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareAlias2("pIController1.getActive.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pIController1.getActive.u", 1, 5, 49, 1089)
DeclareAlias2("pIController1.active_.y", "Value of Boolean output [:#(type=Boolean)]",\
 "pIController1.getActive.u", 1, 5, 49, 1089)
DeclareVariable("pIController1.y_unlim", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pIController1.y_old", "", 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("pIController1.u_antiWindUp", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("pIController1.integral", "", 5, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pIController1.der(integral)", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pIController1.ki_internal", "", "pIController1.ki_in_.k", 1, 5, 54,\
 1024)
DeclareAlias2("pIController1.getInputs.ki_in", "[s-1]", "pIController1.ki_in_.k", 1,\
 5, 54, 1024)
DeclareAlias2("pIController1.getInputs.k_in", "", "pIController1.k_in_.k", 1, 5,\
 53, 1024)
DeclareAlias2("pIController1.getInputs.Ti_in", "[s]", "pIController1.Ti_in_.k", 1,\
 5, 55, 1024)
DeclareAlias2("pIController1.getInputs.y_notActive", "", "pIController1.y_old", 1,\
 5, 51, 1088)
DeclareVariable("pIController1.k_in_.k", "Constant output value", 1, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("pIController1.k_in_.y", "Connector of Real output signal", \
"pIController1.k_in_.k", 1, 5, 53, 1024)
DeclareVariable("pIController1.ki_in_.k", "Constant output value [s-1]", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pIController1.ki_in_.y", "Connector of Real output signal [s-1]",\
 "pIController1.ki_in_.k", 1, 5, 54, 1024)
DeclareVariable("pIController1.Ti_in_.k", "Constant output value [s]", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pIController1.Ti_in_.y", "Connector of Real output signal [s]", \
"pIController1.Ti_in_.k", 1, 5, 55, 1024)
DeclareAlias2("pIController1.y_notActive_.y", "Value of Real output", \
"pIController1.y_old", 1, 5, 51, 1024)
DeclareAlias2("pIController2.u_s", "Connector of setpoint input signal", \
"const.k", 1, 7, 27, 0)
DeclareAlias2("pIController2.u_m", "Connector of measurement input signal", \
"tITO_FOTD.y_2", 1, 5, 7, 0)
DeclareVariable("pIController2.y", "Connector of actuator output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pIController2.u", "Differenz between setpoint and measurement aka control error",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pIController2.invertFeedback", "true, if feedback signal is inverted [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController2.offset", "Operating point, added to proportional output",\
 42, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("pIController2.k", "Proportional gain of controller", 43, -0.8,\
 0.0,0.0,0.0,0,560)
DeclareParameter("pIController2.Ti", "Time constant of Integrator block [s]", 44,\
 0.5, 1E-060,1E+100,0.0,0,560)
DeclareParameter("pIController2.ki", "Integral gain [s-1]", 45, -0.67, 0.0,0.0,\
0.0,0,560)
DeclareVariable("pIController2.use_kInput", "= true, if k defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController2.use_TiInput", "= true, if Ti defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController2.use_kiInput", "= true, if ki defined by input [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController2.yMax", "Upper limit of output", 46, 1, 0.0,0.0,\
0.0,0,560)
DeclareVariable("pIController2.yMin", "Lower limit of output", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareParameter("pIController2.yInitial", "Initial output of controller", 47, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("pIController2.use_activeInput", "= true, if controller is switched on/off externally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pIController2.use_y_notActive", "= true, if output of not activated controller is defined externally. Otherwise output is hold at deactivation. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pIController2.activationTime", "Time when controller is switched on [s]",\
 48, 0.0, 0.0,0.0,0.0,0,560)
DeclareVariable("pIController2.getActive.u", "Connector of Boolean input signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2690)
DeclareAlias2("pIController2.getActive.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "pIController2.getActive.u", 1, 5, 65, 1089)
DeclareAlias2("pIController2.active_.y", "Value of Boolean output [:#(type=Boolean)]",\
 "pIController2.getActive.u", 1, 5, 65, 1089)
DeclareVariable("pIController2.y_unlim", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pIController2.y_old", "", 0.0, 0.0,0.0,0.0,0,2688)
DeclareVariable("pIController2.u_antiWindUp", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("pIController2.integral", "", 6, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pIController2.der(integral)", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pIController2.ki_internal", "", "pIController2.ki_in_.k", 1, 5, 70,\
 1024)
DeclareAlias2("pIController2.getInputs.ki_in", "[s-1]", "pIController2.ki_in_.k", 1,\
 5, 70, 1024)
DeclareAlias2("pIController2.getInputs.k_in", "", "pIController2.k_in_.k", 1, 5,\
 69, 1024)
DeclareAlias2("pIController2.getInputs.Ti_in", "[s]", "pIController2.Ti_in_.k", 1,\
 5, 71, 1024)
DeclareAlias2("pIController2.getInputs.y_notActive", "", "pIController2.y_old", 1,\
 5, 67, 1088)
DeclareVariable("pIController2.k_in_.k", "Constant output value", 1, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("pIController2.k_in_.y", "Connector of Real output signal", \
"pIController2.k_in_.k", 1, 5, 69, 1024)
DeclareVariable("pIController2.ki_in_.k", "Constant output value [s-1]", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pIController2.ki_in_.y", "Connector of Real output signal [s-1]",\
 "pIController2.ki_in_.k", 1, 5, 70, 1024)
DeclareVariable("pIController2.Ti_in_.k", "Constant output value [s]", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pIController2.Ti_in_.y", "Connector of Real output signal [s]", \
"pIController2.Ti_in_.k", 1, 5, 71, 1024)
DeclareAlias2("pIController2.y_notActive_.y", "Value of Real output", \
"pIController2.y_old", 1, 5, 67, 1024)
DeclareAlias2("add.u1", "Connector of Real input signal 1", "pIController.y", 1,\
 5, 24, 0)
DeclareAlias2("add.u2", "Connector of Real input signal 2", "pIController2.y", 1,\
 5, 56, 0)
DeclareAlias2("add.y", "Connector of Real output signal", "tITO_FOTD.u_1", 1, 5,\
 5, 0)
DeclareParameter("add.k1", "Gain of upper input", 49, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("add.k2", "Gain of lower input", 50, 1, 0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_) {
static Real initStore[1];
}
StartDataBlock
StartPreBlock
preCont(DYNX(W_,24),"pIController.y", DYNX(DP_,33), 1);
preCont(DYNX(W_,40),"pIController1.y", DYNX(DP_,40), 0);
preCont(DYNX(W_,56),"pIController2.y", DYNX(DP_,47), 2);
EndPreBlock
UpdateQEvaluate(6)
EndDataBlock
